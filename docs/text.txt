ğŸŸ¦ OnBookingQueueCreate / Update (hook)
 â”‚
 â”œâ”€> avvia transazione â†’ app.RunInTransaction()
 â”‚     â”‚
 â”‚     â”œâ”€â”€> e.App = txApp
 â”‚     â”œâ”€â”€> ğŸŸ© CALL â†’ fxqueuemodule.CalculateFormulas(txApp, e.PRecord)
 â”‚     â”‚
 â”‚     â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚     â”‚   â”‚             fxqueuemodule.CalculateFormulas()                â”‚
 â”‚     â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 â”‚     â”‚
 â”‚     â”‚   ğŸŸ© 1ï¸âƒ£ updateDepQueuesFldAndCheckNormalizeFx
 â”‚     â”‚        â”œâ”€ sostituisce "this." con queue.Id + "."
 â”‚     â”‚        â”œâ”€ ricava gli ID delle parent queues
 â”‚     â”‚        â”œâ”€ aggiorna il campo referenced_queues
 â”‚     â”‚        â””â”€ txApp.UnsafeWithoutHooks().Save(queue) ğŸ§©
 â”‚     â”‚             ğŸŸ§ Se fallisce qui â†’ controllare campi obbligatori o validazione DB
 â”‚     â”‚
 â”‚     â”‚   ğŸŸ© 2ï¸âƒ£ build DAG (FxDag)
 â”‚     â”‚        â”œâ”€ crea nodi principali:
 â”‚     â”‚        â”‚    - actNode
 â”‚     â”‚        â”‚    - minNode
 â”‚     â”‚        â”‚    - maxNode
 â”‚     â”‚        â”‚    - linkedBookingsNode
 â”‚     â”‚        â”‚
 â”‚     â”‚        â”œâ”€ per ciascuna formula modificata:
 â”‚     â”‚        â”‚     ğŸŸ¦ buildDagForValField()
 â”‚     â”‚        â”‚     â”‚
 â”‚     â”‚        â”‚     â”œâ”€ registra nodo principale
 â”‚     â”‚        â”‚     â”œâ”€ ğŸ” risolve variabili formula con fetchUpstreamNodeFromDB
 â”‚     â”‚        â”‚     â”‚     â”œâ”€ FindRecordById(queueId)
 â”‚     â”‚        â”‚     â”‚     â””â”€ WrapRecord[BookingQueue]
 â”‚     â”‚        â”‚     â””â”€ espande i figli (booking_queue_via_referenced_queues)
 â”‚     â”‚        â”‚
 â”‚     â”‚        â””â”€ buildDagForValField(txApp, fxDag, linkedBookingsNode)
 â”‚     â”‚             (sempre eseguito)
 â”‚     â”‚
 â”‚     â”‚   ğŸŸ© 3ï¸âƒ£ TopologicalSort()
 â”‚     â”‚        â”œâ”€ costruisce ordine di calcolo
 â”‚     â”‚        â””â”€ ğŸŸ§ se errore: DAG ciclico o variabile non risolta
 â”‚     â”‚
 â”‚     â”‚   ğŸŸ© 4ï¸âƒ£ Calcolo valori
 â”‚     â”‚        ğŸ” for node in orderedNodes
 â”‚     â”‚            â”œâ”€ costruisce env[queueId][valField]
 â”‚     â”‚            â”œâ”€ expr.Run(node.CompiledProgram, env)
 â”‚     â”‚            â”œâ”€ node.SetVal(newVal)
 â”‚     â”‚            â””â”€ se node.Dirty â†’ Save(node.Queue.Record) ğŸ§©
 â”‚     â”‚
 â”‚     â”‚        ğŸŸ§ Se errore â€œerrore calcolo formula Xâ€:
 â”‚     â”‚           â†’ controllare sintassi formula o variabile non definita
 â”‚     â”‚
 â”‚     â”‚   ğŸŸ© 5ï¸âƒ£ Fine calcolo
 â”‚     â”‚        â””â”€ ritorna nil se tutto OK
 â”‚     â”‚
 â”‚     â””â”€â”€> e.Next() (creazione effettiva record DB)
 â”‚           ğŸŸ§ Se fallisce â†’ errore di validazione o schema
 â”‚
 â””â”€> fine transazione